/**
 * Rides adapter
 */
var Coordinate = require('coordinate');
var Ride = require('ride');

var RidesAdapter = (function() {
	'use strict';

	function RidesAdapter(ridesPerDay, min, max) {
		this.ridesPerDay = ridesPerDay;
		this.min = min;
		this.max = max;
	}

	/**
	 *
	 * @returns {Array}
	 */
	RidesAdapter.prototype.computeRides = function() {
		var ridesList = [];
		var tmp = [];
		var that = this;
		// Iterate over each day
		this.ridesPerDay.forEach(function(day) {

			// For each day :
			//	- filter malformed traces
			//	- concatenates rides arrays

			day.data.forEach(function(rides) {
				

				var dateMin = Date.parse(that.min),
					dateMax = Date.parse(that.max),
					updateAtDate = new Date(day.metadata.updatedAt.$date);

			


				rides.timestamp = rides.timestamp || updateAtDate;

				

			

			var tst = (updateAtDate >= dateMin) && (updateAtDate <= dateMax);
		

				// concatenates rides array
				if ((updateAtDate >= dateMin) && (updateAtDate <= dateMax)) {
					ridesList = ridesList.concat(rides);
				}
			});
		});

		// replace traces by Coordinate objects
		ridesList = ridesList.map(function(trace) {
			return new Coordinate().fromRawTraceObject(trace);
		});

		// Split rides based on delay of inactivity
	    var timeWindow = 5; // 5 min
		var allRides = this.splitIntoRides(ridesList, timeWindow);

		return allRides;
	};

	/**
	 * Split the data set into logical set of coordinate which composed a ride.
	 * This analyze is based over the delay between two coordinate.
	 *
	 * We also compute some metrics over there.
	 *
	 * @param data
	 * @param timeWindow
	 *
	 * @returns Rides list, The Carbon Footprint for this rides list
	 */
	RidesAdapter.prototype.splitIntoRides = function(data, timeWindow) {
		var rides = [];

		rides.push(new Ride());
		for (var i = 1; i < data.length; i++) {
			var t_1 = data[i - 1];	// t-1
			var t = data[i];		// t

			var delta = ((t.timestamp - t_1.timestamp) / 60000).toFixed(2);

			/*
			 * Checking if the current position is in
			 * the current ride or if it's a new ride
			 */
			if (delta > timeWindow) {
				// to overwrite empty rides (less than two points)
				if (rides[rides.length - 1].getLength() > 2) {

					// Compute some metrics over the previous ride
					rides[rides.length - 1].computeMetrics();

					// Let's got to the next ride!
					rides.push(new Ride());
				}
			}

			// add new coordinate
			rides[rides.length - 1].addCoordinate(t);
		}

		// remove last if empty
		if (rides[rides.length - 1].getLength() < 2) {
			rides.pop();
		}

		// compute metrics on the last element
		if (rides[rides.length - 1]) {
			rides[rides.length - 1].computeMetrics();
		}

		return rides;
	};

	return RidesAdapter;

}());

module.exports = RidesAdapter;
